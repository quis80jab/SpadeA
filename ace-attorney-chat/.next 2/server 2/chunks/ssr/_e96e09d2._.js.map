{"version":3,"sources":["../../../../node_modules/framer-motion/src/components/AnimatePresence/utils.ts","../../../../node_modules/framer-motion/src/utils/use-composed-ref.ts","../../../../node_modules/framer-motion/src/components/AnimatePresence/PresenceChild.tsx","../../../../node_modules/framer-motion/src/components/AnimatePresence/index.tsx","../../../../node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx","../../../../node_modules/zustand/esm/react.mjs","../../../../node_modules/zustand/esm/vanilla.mjs","../../../../src/state/historyStore.ts","../../../../src/state/argumentStore.ts","../../../../src/state/markdownManager.ts","../../../../src/agents/agentRouter.ts"],"sourcesContent":["import { isValidElement, Children, ReactElement, ReactNode } from \"react\"\n\nexport type ComponentKey = string | number\n\nexport const getChildKey = (child: ReactElement<any>): ComponentKey =>\n    child.key || \"\"\n\nexport function onlyElements(children: ReactNode): ReactElement<any>[] {\n    const filtered: ReactElement<any>[] = []\n\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child)) filtered.push(child)\n    })\n\n    return filtered\n}\n","/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    children = (\n        <PopChild pop={mode === \"popLayout\"} isPresent={isPresent} anchorX={anchorX} anchorY={anchorY} root={root}>\n            {children}\n        </PopChild>\n    )\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useMemo, useRef, useState } from \"react\"\nimport { LayoutGroupContext } from \"../../context/LayoutGroupContext\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { PresenceChild } from \"./PresenceChild\"\nimport { AnimatePresenceProps } from \"./types\"\nimport { usePresence } from \"./use-presence\"\nimport { ComponentKey, getChildKey, onlyElements } from \"./utils\"\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nexport const AnimatePresence = ({\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\",\n    anchorY = \"top\",\n    root\n}: React.PropsWithChildren<AnimatePresenceProps>) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate)\n\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children])\n\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys =\n        propagate && !isParentPresent ? [] : presentChildren.map(getChildKey)\n\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true)\n\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren)\n\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map<ComponentKey, boolean>())\n\n    /**\n     * Track which components are currently processing exit to prevent duplicate processing.\n     */\n    const exitingComponents = useRef(new Set<ComponentKey>())\n\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren)\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren)\n\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false\n        pendingPresentChildren.current = presentChildren\n\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i])\n\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false)\n                }\n            } else {\n                exitComplete.delete(key)\n                exitingComponents.current.delete(key)\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")])\n\n    const exitingChildren: any[] = []\n\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren]\n\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i]\n            const key = getChildKey(child)\n\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child)\n                exitingChildren.push(child)\n            }\n        }\n\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren\n        }\n\n        setRenderedChildren(onlyElements(nextChildren))\n        setDiffedChildren(presentChildren)\n\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null\n    }\n\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1\n    ) {\n        console.warn(\n            `You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`\n        )\n    }\n\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext)\n\n    return (\n        <>\n            {renderedChildren.map((child) => {\n                const key = getChildKey(child)\n\n                const isPresent =\n                    propagate && !isParentPresent\n                        ? false\n                        : presentChildren === renderedChildren ||\n                          presentKeys.includes(key)\n\n                const onExit = () => {\n                    if (exitingComponents.current.has(key)) {\n                        return\n                    }\n                    exitingComponents.current.add(key)\n\n                    if (exitComplete.has(key)) {\n                        exitComplete.set(key, true)\n                    } else {\n                        return\n                    }\n\n                    let isEveryExitComplete = true\n                    exitComplete.forEach((isExitComplete) => {\n                        if (!isExitComplete) isEveryExitComplete = false\n                    })\n\n                    if (isEveryExitComplete) {\n                        forceRender?.()\n                        setRenderedChildren(pendingPresentChildren.current)\n\n                        propagate && safeToRemove?.()\n\n                        onExitComplete && onExitComplete()\n                    }\n                }\n\n                return (\n                    <PresenceChild\n                        key={key}\n                        isPresent={isPresent}\n                        initial={\n                            !isInitialRender.current || initial\n                                ? undefined\n                                : false\n                        }\n                        custom={custom}\n                        presenceAffectsLayout={presenceAffectsLayout}\n                        mode={mode}\n                        root={root}\n                        onExitComplete={isPresent ? undefined : onExit}\n                        anchorX={anchorX}\n                        anchorY={anchorY}\n                    >\n                        {child}\n                    </PresenceChild>\n                )\n            })}\n        </>\n    )\n}\n","\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n    pop?: boolean\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root, pop }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || pop === false || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size} pop={pop}>\n            {pop === false\n                ? children\n                : React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n","import React from 'react';\nimport { createStore } from 'zustand/vanilla';\n\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity) {\n  const slice = React.useSyncExternalStore(\n    api.subscribe,\n    React.useCallback(() => selector(api.getState()), [api, selector]),\n    React.useCallback(() => selector(api.getInitialState()), [api, selector])\n  );\n  React.useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  const api = createStore(createState);\n  const useBoundStore = (selector) => useStore(api, selector);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = ((createState) => createState ? createImpl(createState) : createImpl);\n\nexport { create, useStore };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);\n\nexport { createStore };\n","import { create } from 'zustand';\nimport type { SavedArgument } from './types';\nimport { createClient } from '@/src/lib/supabase/client';\n\nconst HISTORY_KEY = 'ace_attorney_history';\n\ninterface HistoryActions {\n  saveArgument: (arg: Omit<SavedArgument, 'id' | 'createdAt' | 'starred' | 'is_public' | 'score'> & { score: number; is_public?: boolean }) => Promise<string>;\n  toggleStar: (id: string) => void;\n  deleteArgument: (id: string) => void;\n  getArgument: (id: string) => SavedArgument | undefined;\n  hydrate: () => Promise<void>;\n  setUserId: (userId: string | null) => void;\n}\n\ninterface HistoryState {\n  arguments: SavedArgument[];\n  userId: string | null;\n}\n\nfunction mapDbRow(row: Record<string, unknown>): SavedArgument {\n  return {\n    id: row.id as string,\n    user_id: row.user_id as string,\n    caseData: row.case_data as SavedArgument['caseData'],\n    messages: row.messages as SavedArgument['messages'],\n    outcome: row.outcome as SavedArgument['outcome'],\n    finalHealth: row.final_health as SavedArgument['finalHealth'],\n    exchangeCount: row.exchange_count as number,\n    score: (row.score as number) ?? 0,\n    starred: row.starred as boolean,\n    is_public: row.is_public as boolean,\n    createdAt: new Date(row.created_at as string).getTime(),\n  };\n}\n\nexport const useHistoryStore = create<HistoryState & HistoryActions>((set, get) => ({\n  arguments: [],\n  userId: null,\n\n  setUserId: (userId) => set({ userId }),\n\n  saveArgument: async (arg) => {\n    const { userId } = get();\n    const supabase = createClient();\n\n    if (userId) {\n      // Save to Supabase\n      const { data, error } = await supabase\n        .from('arguments')\n        .insert({\n          user_id: userId,\n          case_data: arg.caseData,\n          messages: arg.messages,\n          outcome: arg.outcome,\n          final_health: arg.finalHealth,\n          exchange_count: arg.exchangeCount,\n          score: arg.score,\n          is_public: arg.is_public ?? true,\n        })\n        .select('id')\n        .single();\n\n      if (error) {\n        console.error('Failed to save argument to Supabase:', error.message);\n        // Fall back to localStorage\n        return saveToLocal(arg, set, get);\n      }\n\n      const id = data.id;\n      const saved: SavedArgument = {\n        ...arg,\n        id,\n        user_id: userId,\n        starred: false,\n        is_public: arg.is_public ?? true,\n        createdAt: Date.now(),\n      };\n      set((state) => ({ arguments: [saved, ...state.arguments] }));\n      return id;\n    } else {\n      return saveToLocal(arg, set, get);\n    }\n  },\n\n  toggleStar: async (id: string) => {\n    const { userId } = get();\n    const current = get().arguments.find((a) => a.id === id);\n    if (!current) return;\n\n    set((state) => ({\n      arguments: state.arguments.map((a) =>\n        a.id === id ? { ...a, starred: !a.starred } : a\n      ),\n    }));\n\n    if (userId) {\n      const supabase = createClient();\n      await supabase\n        .from('arguments')\n        .update({ starred: !current.starred })\n        .eq('id', id);\n    } else {\n      persistLocal(get);\n    }\n  },\n\n  deleteArgument: async (id: string) => {\n    const { userId } = get();\n\n    set((state) => ({\n      arguments: state.arguments.filter((a) => a.id !== id),\n    }));\n\n    if (userId) {\n      const supabase = createClient();\n      await supabase.from('arguments').delete().eq('id', id);\n    } else {\n      persistLocal(get);\n    }\n  },\n\n  getArgument: (id: string) => {\n    return get().arguments.find((a) => a.id === id);\n  },\n\n  hydrate: async () => {\n    const { userId } = get();\n\n    if (userId) {\n      const supabase = createClient();\n      const { data, error } = await supabase\n        .from('arguments')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false });\n\n      if (!error && data) {\n        set({ arguments: data.map(mapDbRow) });\n        return;\n      }\n    }\n\n    // Fall back to localStorage\n    try {\n      const raw = localStorage.getItem(HISTORY_KEY);\n      if (raw) {\n        const data = JSON.parse(raw) as SavedArgument[];\n        // Ensure old data has new fields\n        const migrated = (Array.isArray(data) ? data : []).map((a) => ({\n          ...a,\n          score: a.score ?? 0,\n          is_public: a.is_public ?? true,\n        }));\n        set({ arguments: migrated });\n      }\n    } catch {\n      // Ignore\n    }\n  },\n}));\n\n// ─── localStorage helpers for unauthenticated users ───\n\nfunction saveToLocal(\n  arg: Omit<SavedArgument, 'id' | 'createdAt' | 'starred' | 'is_public'> & { is_public?: boolean },\n  set: (fn: (state: HistoryState) => Partial<HistoryState>) => void,\n  get: () => HistoryState & HistoryActions,\n): string {\n  const id = `arg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n  const saved: SavedArgument = {\n    ...arg,\n    id,\n    createdAt: Date.now(),\n    starred: false,\n    is_public: arg.is_public ?? true,\n  };\n  set((state) => ({ arguments: [saved, ...state.arguments] }));\n  setTimeout(() => persistLocal(get), 0);\n  return id;\n}\n\nfunction persistLocal(get: () => HistoryState) {\n  try {\n    const { arguments: args } = get();\n    localStorage.setItem(HISTORY_KEY, JSON.stringify(args));\n  } catch {\n    // localStorage not available\n  }\n}\n","import { create } from 'zustand';\nimport {\n  ArgumentState,\n  CaseData,\n  HealthState,\n  Message,\n  SuggestedReply,\n  GamePhase,\n  PointUpdate,\n  FallacyEntry,\n  AssumptionEntry,\n} from './types';\nimport {\n  applyPointUpdates,\n  applyFallacies,\n  applyAssumptions,\n  recalcScores,\n  createInitialAnalysis,\n} from './markdownManager';\n\nconst STORAGE_KEY = 'ace_attorney_state';\n\nconst DEFAULT_HEALTH: HealthState = { attorneyHP: 100, defendantHP: 100, maxHP: 100 };\n\ninterface ArgumentActions {\n  initCase: (caseData: CaseData) => void;\n  setPhase: (phase: GamePhase) => void;\n  reset: () => void;\n  addMessage: (text: string, sender: 'attorney' | 'user', intensity?: number) => void;\n  setSuggestions: (suggestions: SuggestedReply[]) => void;\n  incrementExchange: () => void;\n  updatePoints: (updates: PointUpdate[]) => void;\n  updateAnalysis: (fallacies: FallacyEntry[], assumptions: AssumptionEntry[]) => void;\n  setGeneratingCase: (v: boolean) => void;\n  setAttorneyThinking: (v: boolean) => void;\n  setSuggestionsLoading: (v: boolean) => void;\n  setOutcome: (outcome: 'won' | 'lost') => void;\n  applyDamage: (toAttorney: number, toDefendant: number) => 'none' | 'attorney_ko' | 'defendant_ko';\n  persist: () => void;\n  hydrate: () => void;\n}\n\nconst initialState: ArgumentState = {\n  phase: 'splash',\n  caseData: null,\n  attorneyPoints: [],\n  defendantPoints: [],\n  analysis: createInitialAnalysis(),\n  health: { ...DEFAULT_HEALTH },\n  messages: [],\n  suggestions: [],\n  exchangeCount: 0,\n  isGeneratingCase: false,\n  isAttorneyThinking: false,\n  isSuggestionsLoading: false,\n  outcome: null,\n};\n\nexport const useArgumentStore = create<ArgumentState & ArgumentActions>((set, get) => ({\n  ...initialState,\n\n  initCase: (caseData: CaseData) =>\n    set({\n      caseData,\n      attorneyPoints: caseData.attorney_points,\n      defendantPoints: caseData.defendant_points,\n      analysis: {\n        ...createInitialAnalysis(),\n        attorneyScore: {\n          validPoints: caseData.attorney_points.length,\n          fallacies: 0,\n          challenged: 0,\n        },\n        defendantScore: {\n          validPoints: caseData.defendant_points.length,\n          fallacies: 0,\n          challenged: 0,\n        },\n      },\n      health: { ...DEFAULT_HEALTH },\n      messages: [],\n      suggestions: [],\n      exchangeCount: 0,\n      outcome: null,\n      phase: 'intro',\n    }),\n\n  setPhase: (phase: GamePhase) => set({ phase }),\n\n  reset: () => set({ ...initialState }),\n\n  addMessage: (text: string, sender: 'attorney' | 'user', intensity?: number) => {\n    const msg: Message = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,\n      text,\n      sender,\n      timestamp: Date.now(),\n      intensity,\n    };\n    set((state) => ({ messages: [...state.messages, msg] }));\n  },\n\n  setSuggestions: (suggestions: SuggestedReply[]) => set({ suggestions }),\n\n  incrementExchange: () =>\n    set((state) => ({ exchangeCount: state.exchangeCount + 1 })),\n\n  updatePoints: (updates: PointUpdate[]) =>\n    set((state) => {\n      const result = applyPointUpdates(state.attorneyPoints, state.defendantPoints, updates);\n      const analysis = recalcScores(state.analysis, result.attorneyPoints, result.defendantPoints);\n      return { ...result, analysis };\n    }),\n\n  updateAnalysis: (fallacies: FallacyEntry[], assumptions: AssumptionEntry[]) =>\n    set((state) => {\n      let analysis = state.analysis;\n      if (fallacies.length > 0) {\n        analysis = applyFallacies(analysis, fallacies, state.exchangeCount);\n      }\n      if (assumptions.length > 0) {\n        analysis = applyAssumptions(analysis, assumptions);\n      }\n      return { analysis };\n    }),\n\n  setGeneratingCase: (v: boolean) => set({ isGeneratingCase: v }),\n  setAttorneyThinking: (v: boolean) => set({ isAttorneyThinking: v }),\n  setSuggestionsLoading: (v: boolean) => set({ isSuggestionsLoading: v }),\n\n  setOutcome: (outcome: 'won' | 'lost') => set({ outcome, phase: 'ended' }),\n\n  applyDamage: (toAttorney: number, toDefendant: number) => {\n    const state = get();\n    const newAttorneyHP = Math.max(0, state.health.attorneyHP - toAttorney);\n    const newDefendantHP = Math.max(0, state.health.defendantHP - toDefendant);\n\n    set({\n      health: {\n        ...state.health,\n        attorneyHP: newAttorneyHP,\n        defendantHP: newDefendantHP,\n      },\n    });\n\n    if (newAttorneyHP <= 0) return 'attorney_ko';\n    if (newDefendantHP <= 0) return 'defendant_ko';\n    return 'none';\n  },\n\n  persist: () => {\n    try {\n      const state = get();\n      const data: ArgumentState = {\n        phase: state.phase,\n        caseData: state.caseData,\n        attorneyPoints: state.attorneyPoints,\n        defendantPoints: state.defendantPoints,\n        analysis: state.analysis,\n        health: state.health,\n        messages: state.messages,\n        suggestions: state.suggestions,\n        exchangeCount: state.exchangeCount,\n        isGeneratingCase: false,\n        isAttorneyThinking: false,\n        isSuggestionsLoading: false,\n        outcome: state.outcome,\n      };\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    } catch {\n      // localStorage not available (SSR)\n    }\n  },\n\n  hydrate: () => {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (raw) {\n        const data = JSON.parse(raw) as ArgumentState;\n        set({\n          ...data,\n          health: data.health ?? { ...DEFAULT_HEALTH },\n          isGeneratingCase: false,\n          isAttorneyThinking: false,\n          isSuggestionsLoading: false,\n        });\n      }\n    } catch {\n      // Ignore hydration errors\n    }\n  },\n}));\n","import {\n  CaseData,\n  CasePoint,\n  AnalysisState,\n  Message,\n  PointUpdate,\n  FallacyEntry,\n  AssumptionEntry,\n} from './types';\n\n// ─── Generators (structured data → markdown strings for agent context) ───\n\nexport function generateIssueMd(caseData: CaseData): string {\n  return `# ${caseData.title}\n\n## Charge\n${caseData.charge}\n\n## Context\n${caseData.context}\n\n## The Real Question\n${caseData.philosophical_tension}\n`;\n}\n\nexport function generatePointsMd(\n  points: CasePoint[],\n  side: 'prosecution' | 'defense'\n): string {\n  const title = side === 'prosecution' ? 'Prosecution Arguments' : 'Defense Arguments';\n  const rows = points\n    .map((p) => `| ${p.id} | ${p.claim} | ${p.evidence} | ${p.status} |`)\n    .join('\\n');\n\n  const concessions = points\n    .filter((p) => p.status === 'refuted')\n    .map((p) => `- ${p.id}: ${p.claim}`)\n    .join('\\n');\n\n  return `# ${title}\n\n| ID | Claim | Evidence | Status |\n|----|-------|----------|--------|\n${rows}\n\n## Concessions\n${concessions || '- None'}\n`;\n}\n\nexport function generateAnalysisMd(analysis: AnalysisState): string {\n  const assumptionRows = analysis.assumptions\n    .map((a) => `| ${a.side} | ${a.assumption} | ${a.state} |`)\n    .join('\\n');\n\n  const fallacyRows = analysis.fallacies\n    .map((f) => `| ${f.side} | ${f.type} | ${f.context} | ${f.exchangeNumber} |`)\n    .join('\\n');\n\n  return `# Argument Analysis\n\n## Key Assumptions\n| Side | Assumption | State |\n|------|-----------|-------|\n${assumptionRows || '| - | - | - |'}\n\n## Fallacies Identified\n| Side | Type | Context | Exchange # |\n|------|------|---------|-----------|\n${fallacyRows || '| - | - | - | - |'}\n\n## Score\n- Attorney: ${analysis.attorneyScore.validPoints} valid points, ${analysis.attorneyScore.fallacies} fallacies, ${analysis.attorneyScore.challenged} challenged\n- Defendant: ${analysis.defendantScore.validPoints} valid points, ${analysis.defendantScore.fallacies} fallacies, ${analysis.defendantScore.challenged} challenged\n`;\n}\n\nexport function generateConversationMd(messages: Message[]): string {\n  if (messages.length === 0) return '# Conversation Log\\n\\n(No exchanges yet)\\n';\n\n  let md = '# Conversation Log\\n\\n';\n  let exchangeNum = 0;\n  let lastSender = '';\n\n  for (const msg of messages) {\n    if (msg.sender === 'attorney' && lastSender !== 'attorney') {\n      exchangeNum++;\n      md += `## Exchange ${exchangeNum}\\n`;\n    }\n    const label = msg.sender === 'attorney' ? 'Attorney' : 'User';\n    md += `**${label}:** ${msg.text}\\n\\n`;\n    lastSender = msg.sender;\n  }\n\n  return md;\n}\n\n// ─── Updaters (apply agent outputs to structured data) ───\n\nexport function applyPointUpdates(\n  attorneyPoints: CasePoint[],\n  defendantPoints: CasePoint[],\n  updates: PointUpdate[]\n): { attorneyPoints: CasePoint[]; defendantPoints: CasePoint[] } {\n  const newAttorney = [...attorneyPoints];\n  const newDefendant = [...defendantPoints];\n\n  for (const update of updates) {\n    const aIdx = newAttorney.findIndex((p) => p.id === update.id);\n    if (aIdx >= 0) {\n      newAttorney[aIdx] = { ...newAttorney[aIdx], status: update.new_status };\n      continue;\n    }\n    const dIdx = newDefendant.findIndex((p) => p.id === update.id);\n    if (dIdx >= 0) {\n      newDefendant[dIdx] = { ...newDefendant[dIdx], status: update.new_status };\n    }\n  }\n\n  return { attorneyPoints: newAttorney, defendantPoints: newDefendant };\n}\n\nexport function applyFallacies(\n  analysis: AnalysisState,\n  fallacies: FallacyEntry[],\n  exchangeNumber: number\n): AnalysisState {\n  const newFallacies = [\n    ...analysis.fallacies,\n    ...fallacies.map((f) => ({ ...f, exchangeNumber })),\n  ];\n\n  const attorneyFallacies = newFallacies.filter((f) => f.side === 'attorney').length;\n  const defendantFallacies = newFallacies.filter((f) => f.side === 'defendant').length;\n\n  return {\n    ...analysis,\n    fallacies: newFallacies,\n    attorneyScore: { ...analysis.attorneyScore, fallacies: attorneyFallacies },\n    defendantScore: { ...analysis.defendantScore, fallacies: defendantFallacies },\n  };\n}\n\nexport function applyAssumptions(\n  analysis: AnalysisState,\n  assumptions: AssumptionEntry[]\n): AnalysisState {\n  const newAssumptions = [...analysis.assumptions];\n\n  for (const update of assumptions) {\n    const idx = newAssumptions.findIndex(\n      (a) => a.side === update.side && a.assumption === update.assumption\n    );\n    if (idx >= 0) {\n      newAssumptions[idx] = { ...newAssumptions[idx], state: update.new_state };\n    } else {\n      newAssumptions.push({\n        side: update.side,\n        assumption: update.assumption,\n        state: update.new_state,\n      });\n    }\n  }\n\n  return { ...analysis, assumptions: newAssumptions };\n}\n\nexport function recalcScores(\n  analysis: AnalysisState,\n  attorneyPoints: CasePoint[],\n  defendantPoints: CasePoint[]\n): AnalysisState {\n  return {\n    ...analysis,\n    attorneyScore: {\n      ...analysis.attorneyScore,\n      validPoints: attorneyPoints.filter(\n        (p) => p.status === 'unchallenged' || p.status === 'proven'\n      ).length,\n      challenged: attorneyPoints.filter((p) => p.status === 'challenged').length,\n    },\n    defendantScore: {\n      ...analysis.defendantScore,\n      validPoints: defendantPoints.filter(\n        (p) => p.status === 'unchallenged' || p.status === 'proven'\n      ).length,\n      challenged: defendantPoints.filter((p) => p.status === 'challenged').length,\n    },\n  };\n}\n\nexport function createInitialAnalysis(): AnalysisState {\n  return {\n    assumptions: [],\n    fallacies: [],\n    attorneyScore: { validPoints: 0, fallacies: 0, challenged: 0 },\n    defendantScore: { validPoints: 0, fallacies: 0, challenged: 0 },\n  };\n}\n","import {\n  generateIssueMd,\n  generatePointsMd,\n  generateAnalysisMd,\n  generateConversationMd,\n} from '@/src/state/markdownManager';\nimport { useArgumentStore } from '@/src/state/argumentStore';\n\n// ─── Build context string from current store state ───\n\nfunction buildContext(): string {\n  const state = useArgumentStore.getState();\n  const parts: string[] = [];\n\n  if (state.caseData) {\n    parts.push('=== issue.md ===');\n    parts.push(generateIssueMd(state.caseData));\n  }\n  if (state.attorneyPoints.length > 0) {\n    parts.push('=== attorney_points.md ===');\n    parts.push(generatePointsMd(state.attorneyPoints, 'prosecution'));\n  }\n  if (state.defendantPoints.length > 0) {\n    parts.push('=== defendant_points.md ===');\n    parts.push(generatePointsMd(state.defendantPoints, 'defense'));\n  }\n  if (state.messages.length > 0) {\n    parts.push('=== conversation.md ===');\n    parts.push(generateConversationMd(state.messages));\n  }\n  parts.push('=== analysis.md ===');\n  parts.push(generateAnalysisMd(state.analysis));\n\n  return parts.join('\\n\\n');\n}\n\n// ─── Call server-side API route ───\n\nasync function callAgentAPI(body: Record<string, unknown>): Promise<string> {\n  const response = await fetch('/api/agent', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const data = await response.json().catch(() => ({ error: 'Request failed' }));\n    throw new Error(data.error || `API error (${response.status})`);\n  }\n\n  const data = await response.json();\n  return data.result;\n}\n\n// ─── Agent Callers ───\n\nexport async function callCaseCreator(): Promise<string> {\n  return callAgentAPI({ agent: 'case_creator' });\n}\n\nexport async function callLawyer(\n  userMessage: string,\n  surrender: boolean = false\n): Promise<string> {\n  const context = buildContext();\n  return callAgentAPI({\n    agent: 'lawyer',\n    context,\n    userMessage,\n    surrender,\n  });\n}\n\nexport async function callDefendant(exchangeCount: number): Promise<string> {\n  const context = buildContext();\n  return callAgentAPI({\n    agent: 'defendant',\n    context,\n    exchangeCount,\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6]}